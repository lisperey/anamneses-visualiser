"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateString = exports.getConnectionName = exports.handleRetry = exports.getConnectionPrefix = exports.getConnectionToken = exports.getModelToken = void 0;
const knex_constants_1 = require("../knex.constants");
const operators_1 = require("rxjs/operators");
const node_crypto_1 = require("node:crypto");
const common_1 = require("@nestjs/common");
const circular_dependency_exception_1 = require("../exceptions/circular-dependency.exception");
const logger = new common_1.Logger('KnexModule');
/**
 * This function generates an injection token for an Model
 * @param {Function} This parameter can either be a Model
 * @param {string} [connection='default'] Connection name
 * @returns {string} The Entity injection token
 */
function getModelToken(model, connection = knex_constants_1.DEFAULT_CONNECTION_NAME) {
    if (model === null || model === undefined) {
        throw new circular_dependency_exception_1.CircularDependencyException('@InjectModel()');
    }
    const connectionPrefix = getConnectionPrefix(connection);
    return `${connectionPrefix}${model.name}`;
}
exports.getModelToken = getModelToken;
function getConnectionToken(connection = knex_constants_1.DEFAULT_CONNECTION_NAME) {
    if (typeof connection === 'string') {
        return connection;
    }
    return `${connection.name || knex_constants_1.DEFAULT_CONNECTION_NAME}`;
}
exports.getConnectionToken = getConnectionToken;
/**
 * This function returns a Connection prefix based on the connection name
 * @param {KnexModuleOptions | string} [connection='default'] This optional parameter is either
 * a KnexModuleOptions or a string.
 * @returns {string | Function} The Connection injection token.
 */
function getConnectionPrefix(connection = knex_constants_1.DEFAULT_CONNECTION_NAME) {
    if (connection === knex_constants_1.DEFAULT_CONNECTION_NAME) {
        return '';
    }
    if (typeof connection === 'string') {
        return connection + '_';
    }
    if (connection.name === knex_constants_1.DEFAULT_CONNECTION_NAME || !connection.name) {
        return '';
    }
    return connection.name + '_';
}
exports.getConnectionPrefix = getConnectionPrefix;
function handleRetry(retryAttempts = 9, retryDelay = 3000) {
    return (source) => source.pipe((0, operators_1.retryWhen)((e) => e.pipe((0, operators_1.scan)((errorCount, error) => {
        logger.error(`Unable to connect to the database. Retrying (${errorCount + 1})...`, error.stack);
        if (errorCount + 1 >= retryAttempts) {
            throw error;
        }
        return errorCount + 1;
    }, 0), (0, operators_1.delay)(retryDelay))));
}
exports.handleRetry = handleRetry;
function getConnectionName(options) {
    return options && options.name ? options.name : knex_constants_1.DEFAULT_CONNECTION_NAME;
}
exports.getConnectionName = getConnectionName;
const generateString = () => (0, node_crypto_1.randomUUID)();
exports.generateString = generateString;
